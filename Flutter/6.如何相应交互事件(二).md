使用 **GestureDetector** 可以获得各种类型的点击事件回调，因此你可以创建出能够处理各种点击事件的 Widget 来。  
  
# 1.GestureDetector 常用手势

- onTap：单击

- onDoubleTap：双击

- onLongPress：长按

- onTapUp：手指抬起来时

- onTapDown：手指触碰屏幕时

- onTapCancel：点击没有完成

- onVerticalDragDown：手指刚接触屏幕时，随后开始垂直方向上的拖动

- onVerticalDragStart：垂直方向上的拖动开始时 

- onVerticalDragUpdate：垂直方向上的拖动更新时

- onVerticalDragEnd：垂直方向上的拖动结束时   

- onVerticalDragCancel：垂直拖动没有完成

- onHorizontallyDragDown：手指刚接触屏幕时，随后开始水平方向上的拖动

- onHorizontallyDragStart：水平方向上的拖动开始时 

- onHorizontallyDragUpdate：水平方向上的拖动更新时

- onHorizontallyDragEnd：水平方向上的拖动结束时   

- onHorizontallyDragCancel：水平拖动没有完成

- onScaleStart：开始缩放时，初始 scale 为 1.0

- onScaleUpdate：缩放更新时

- onScaleEnd：缩放结束

- onPanDown：手指触摸屏幕时

- onPanUpdate：手指移动时

- onPanEnd：滑动结束时

# 2.如何使用 GestureDetector

1. 使用 **GestureDetector** 创建一个可交互的 Widget。  
    
    ```
    class TapBox extends StatefulWidget {
    
      final bool active;
      // 定义一个函数，外界传入后可被调用
      final ValueChanged<bool> onChanged;
    
      TapBox({Key key, this.active, this.onChanged}) : super(key: key);
    
      @override
      State<StatefulWidget> createState() {
        // TODO: implement createState
        return _TabBox();
      }
    }
    
    class _TabBox extends State<TapBox> {
      bool _highlight = false;
    
      void _handleTapDown(TapDownDetails details) {
        setState(() {
          _highlight = true;
        });
      }
    
      void _handleTapUp(TapUpDetails details) {
        setState(() {
          _highlight = false;
        });
      }
    
      void _handleTapCancel() {
        setState(() {
          _highlight = false;
        });
      }
    
      void _handleTap() {
        // 通过 widget 可以获得其成员变量
        widget.onChanged(!widget.active);
      }
    
      Widget build(BuildContext context) {
        // This example adds a green border on tap down.
        // On tap up, the square changes to the opposite state.
        return GestureDetector(
          onTapDown: _handleTapDown,
          // Handle the tap events in the order that
          onTapUp: _handleTapUp,
          // they occur: down, up, tap, cancel
          onTap: _handleTap,
          onTapCancel: _handleTapCancel,
          child: Container(
            child: Center(
              //
              child: Text(widget.active ? 'Active' : 'Inactive',
                  style: TextStyle(fontSize: 32.0, color: Colors.white)),
            ),
            width: 200.0,
            height: 200.0,
            decoration: BoxDecoration(
              color: widget.active ? Colors.lightGreen[700] : Colors.grey[600],
              border: _highlight
                  ? Border.all(
                      color: Colors.teal[700],
                      width: 10.0,
                    )
                  : null,
            ),
          ),
        );
      }
    }
    ```

2. 使用这个 Widget。  
    
    
   ```
   class ParentWidget extends StatefulWidget {
     @override
     State<StatefulWidget> createState() {
       // TODO: implement createState
       return _ParentWidget();
     }
   }
   
   class _ParentWidget extends State<ParentWidget> {
     bool _active = false;
   
     void _handleTapBoxChanged(bool newValue) {
       setState(() {
         _active = newValue;
       });
     }
   
     @override
     Widget build(BuildContext context) {
       // TODO: implement build
       return Container(
         child: TapBox(
           active: _active,
           // 传入函数
           onChanged: _handleTapBoxChanged,
         ),
       );
     }
   }
   ```
   
运行效果：  

![](https://raw.githubusercontent.com/chenBingX/img/master/Flutter/Flutter-demo9.gif)  

# 3.使用 Listener 监听触摸事件

除了 GestureDetector，Flutter 还提供了 Listener 来监听触摸事件。  

它也是一个 Widget，使用它包裹一个 Widget，能够处理该 Widget 上发生的触摸事件。  

## 3.1 Listener 的常用属性

|属性|类型|说明|
|---|---|---|
|onPointerDown|(PointerDownEvent event){}|按下时触发|
|onPointerMove|(PointerDownEvent event){}|移动时触发|
|onPointerEnter|(PointerDownEvent event){}|进入Widget区域时触发|
|onPointerExit|(PointerDownEvent event){}|离开Widget区域时触发|
|onPointerUp|(PointerDownEvent event){}|离开屏幕时触发|
|onPointerDown|(PointerDownEvent event){}|按下时触发|
|onPointerCancel|(PointerDownEvent event){}|取消触摸时触发|
|behavior|HitTestBehavior|控制事件传递。这个下面再说明|

## 3.2 Listener 的使用

```
Listener(
  onPointerUp: (e){
    Navigator.pop(context);
  },
  child: Container(
    height: 80,
    color: Colors.blue,
    alignment: Alignment.center,
    child: Text(
      text,
      style: TextStyle(
          color: Colors.white, decoration: TextDecoration.none),
    ),
  ),
)
```

## 3.3 HitTestBehavior

HitTestBehavior 用于控制事件的传递方式。  

- HitTestBehavior.deferToChild
    
    只有有子 Widget 通过了 Hit-Test，才接收一系列的事件，接收区域也会被限制在该子 Widget 区域中。  
    
- HitTestBehavior.opaque
    
    Widget 能够通过 Hit-Test，接收事件，且能阻止在它之前的 Widget（直观来看就是被它挡住的 Widget）接收事件。  
    
- HitTestBehavior.translucent
    
     Widget 能够通过 Hit-Test，接收事件，且不会阻止它之前的 Widget（直观来看就是被它挡住的 Widget）接收事件。


## 3.4 PointerEvent

