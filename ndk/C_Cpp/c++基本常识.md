# 头文件
c++中引用系统提供的头文件不带.h。

```
#include <stdio.h>  // c
#include <iostream> // c++ 
```
引用自己的头文件。

```
#include "myhead.h"
```


# 声明、定义、与赋值
- 声明不会分配内存，仅指定变量的类型和名称。使用`extern`关键字来表示声明。
- 定义会分配内存，可以使用`sizeof()`函数查看定义时分配了多少内存。定义的时候可以为变量指定初始值。定义包含了声明。一个变量只能被定义一次。
  
- 在c++中，变量只要声明在使用之前就可以，不用必须申明在头部。
- 一个变量可以被声明多次，但只能被定义一次。


# 类和继承
c++中的类使用class来定义。

```
class Hero
{
    public:
        
        
}
```

## friend class
如果B类为A类的friend class，那么B类可以访问A类的私有成员，但是A类不能访问B
类的。


# 基本关键字

# unsigned 和 sign
- unsigned 范围从0开始。
- sign 范围正常。

```
unsigned int // 范围为 0 ～ 4294967295；
sign int //范围为 -2,147,483,648 ～ -2,147,483,647
```


## extern
extern关键字是用来声明变量或函数的，表明该变量或函数可能在其它文件被定义。函数声明时可以省略extern。  

在cpp_demo.cpp中声明
```
extern int a_test;

int fun_test()
{
    
}
```
在cpp_demo2.cpp中

```
extern int fun_test();
int a_test = 1;
int main()
{
    fun_test();
}
```

## const
const修饰变量，表明该变量是常量成员。它只能在构造函数中初始化，并且一旦初始化就不能再修改其值。在函数执行完后，const变量的内存会被释放。每个对象会有一个自己版本的const变量。   

const可以用作定义数组的大小，因为它的值不会改变，而普通变量不行是因为它们的值可能被改变。

```
const int SIZE = 10;
char str[SIZE] = {0};
```




### 修饰指针变量
```
const int* i;  //指针i指向的内容不可被修改
int* const i;  //指针i不可以被修改（只能指向一个地址），但内容可以被修改

const int* const i;  //指针和内容都不可以被修改
```

### 修饰函数

```
// 参数i在函数内不能被改变
void fun(const int i)
{
    i++; //非法操作
}

// const函数内不能修改任何成员变量，不能调用非const成员函数
void fun(int i) const
{
    
}

// const修饰的返回值如果为基本类型是没有用的。编译器会自动忽略。
const int fun()
{
    
}

// const修饰非基本类型返回值，不能做左值。且返回值的别名也必须使用const修饰。
const Hero fun()
{
    
}

```



## static
- static修饰变量，表明该变量是静态数据成员。
- 它的作用范围只是本文件内。A.cpp中的static变量，B.cpp是访问不到的。对比extern的概念理解。
- static变量在函数执行完后，其储存空间不会释放。因为它是该类所有实例对象所共享的，其它对象可能还会用到。
- static变量会默认初始化
```
static int i;  //这里i默认为0
```


## const static和static const
二者是一样的。表明变量不能被修改，并且是静态的。需要直接在声明的地方初始化。

## #defind
用于定义一个宏常量，格式为：  
#defind 宏名 表达式/变量/函数
```
#defind PI 3.141592653
#defind SUM(x) (x+1)
#defind LOGE(...) ＿android_log＿print(ANDROID_LOG_ERROR, “TAG”, ＿VA_ARGS＿)
#define MIN(a,b) (a<b ? a : b)
```

> ⚠️注意，`defind` 语句结尾不需要 `;`，否则引用时会出现错误。

## ,
","可用于连接表达式，如：
```
x = 1;
y = (x+1, x/2);
```
上面y的值为1。

## sizeof
sizeof是单目运算符，返回变量或类型的字节长度。
```
sizeof(double); //8
sizeof(int);  //2
```

## &
&除了作为位运算符外，还被用作取变量的地址。
```
//定义变量
int *p, a;
a = 10;
p = &a; //取出变量a的地址，储存在指针p中
```

## *

### 一级指针
*还被用作指针运算符。  

上面的例子中p是指针变量，它保存了变量a的地址，`*p`表示通过p保存的地址找到相应的值，即a的值。就是说`*p`和a的值是相同的。

### 二级指针

```
char **p;
```

`p` 是一个二级指针变量。它表示 `*p` 的地址。

在函数参数中，如果只使用一级指针变量，那传入的就是一个复制品，会产生一个新的指针指向同一块内存。

使用二级指针，就能传入一个指针的地址，就可以修改指针执行的内存的内容了。

## 指针变量强转
先看各种基本类型变量的空间分配情况：

类型 | 占用空间（单位：字节）
---|---
char | 1
short | 2
int | 4
float | 4
long | 8
double | 8

根据上面的标，结合例子说明：

```
// 定义指针p指向"0123456789"的首端
char* p = "0123456789";
// 强制转换指针p的类型为int*，并赋值给指针p0
int* p0 = (int*)p;
// 指针p0右移一个储存单元，即移动了4个字节
int* p1 = p0 + 1;
cout<<"p1所指空间的值："<<p1<<endl;

输出：
p1所指空间的值：456789
```
上面例子说明，指针类型强制转换后，会根据转换后的类型占用的空间来进行指针运算的。

## void*
void*是无类型指针，它可以指向任何类型的指针。

```
char* c = 'a';
void* v;
v = c; //把指针c赋值给指针变量v
```

# 高尾端和低尾端储存
- 高尾端（大端）：数据的尾端字节存储在内存的高地址。即头端字节存储在内存的低地址，数据依序增加存储。 
- 低尾端（小端）：数据的尾端字节存储在内存的低地址。即头端字节存储在内存的高地址，数据依序递减存储。  


在16进制编译器中，int型数据0123的16进制编码为：0x30 0x31 0x32 0x33。  

其高尾端储存方式为30313233，转换为10进制为808530483。  

其低尾端储存方式为33323130，转换为10进制为858927408。


## malloc()
用于申请一段内存。切记，申请后一定要记得调用`free()`函数释放。

```
char* p;
p = (char*)malloc(10); 
//表示申请了一段10 byte的内存，并且指定只能储存char*类型。
//现在可以通过指针p来操作这段内存了。
```
注意，申请出内存之后，指针p是指向这段内存的首地址的，如果中间有偏移指针的操作，可能意味着操作后指针p的位置之前的内存我们就无法获取了。


## memset()
用于初始化一段内存。

```
memset(p, 0 ,10);  
// 将上面申请的内存，从0到10全部初始化。


```


## free()
用于释放内存。比如上面申请的10 byte内存，可以调用`free(p)`来释放调。

## const
修饰变量，表示该变量是一个常量。被它修饰的变量和指针是不可以改变的，并且作用范围是本文件内。除非该文件被其它文件引用。

```
const int a = 0;

const int* p = &a;
```

## static_cast<T>()
c++中用于类型转换。

```
int i;
float f = 166.71;
i = static_cast<int>(f);

i的值为166
```



## inline
inline关键字定义函数，使其成为内联函数。内联函数在调用时将被展开，就是以一段代码出现，而不是函数调用。  

注意，inline必须与函数体放在一起才能使函数成为内联函数，不是声明哦！  

内联函数可以被定义多次，每个文件优先使用自己的内联函数。  

内联函数应该写在头文件里。  

函数体较大的函数不应该作为内联函数，因为它的执行时间大于组织调用函数的时间。

# 析构函数

```
class Hero
{
    public:
        Hero();
        ~Hero();  //会在对象被删除前调用。
}

Hero::Hero()
{
    
}

Hero::~Hero()
{
    
}

```

# 接口（虚函数）
只有虚函数，即加了virtual关键字的函数才能实现多态。

```
class Hero
{
    public:
        virtual int fun() = 0;  //虚函数，用来抽象函数。派生类必须重载虚函数。
}

class BladeMaster:public Hero
{
    public:
        int fun()
        {
            
        }
}
```

# 零零碎碎

- 一个源文件中的函数如果被定义为 **static**，在其他文件中 **include** 它的头文件，是不能够获取到这个 **static** 的方法的，因为它是属于源文件的，和头文件中的已经不是一个函数了。

- JNI 中的静态函数的第二个参数，是 Java 调用类的类对象；非静态函数，是 Java 调用对象的实例。

- 根据 CPU 读取数据的方式不同，二进制的储存方式不一样：
    - 小端：把数据的高位保存在高内存地址中，从左往右
    - 大端：把数据的高位保存在低内存地址中，从右往左

    比较常见的是 **小端储存** 方式，如 **x86**、**arm** 等。

    判断 CPU 是大端还是小端。

    ```
    int i=1;   
    char *p=(char *)&i;   
    if(*p == 1)     
        printf("小端模式"); 
    else 
        printf("大端模式");
    ```

